[TOC]
## `JavaScript`读书笔记

> 备注：为了防止标签错乱，现在规定，标题用 `##` ，一级标题是`###` ， 二级是`####` ， 三级是 `#####`。

### `DOM`

内容：
> 理解包含不同层次节点的`DOM`

> 使用不同的节点类型

> 克服浏览器兼容性问题及各种陷阱

`DOM`(文档对象模型)是针对`HTML`和`XML`文档的一个`API`(应用程序编程接口)。`DOM`脱胎于`Netscape`及微软公司创始的`DHTML`(动态`HTML`)，但现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。

`1998`年`10`月`DOM``1`级规范成为`W3C`的推荐标准，为基本的文档及查询提供了接口。

> `IE`中的所有`DOM`对象都是以`COM`对象的形式实现的，这意味着`IE`中的`DOM`对象与原生`Javascript`对象的行为或者活动特定并不一致。

#### 节点层次

`DOM`可以将任何`HTML`或`XML`文档描绘成一个由多节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及(或)标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的`HTML`为例：

```html
<html>
	<head>
		<title>Sample Page</title>
	</head>
	<body>
		<p>Hello World!</p>
	</body>
</html>
```

可以将这个简单的`HTML`文档表示为一个层次结构，如下图所示。

文档节点是每个文档的根节点。在这里，文档节点只有一个子节点。即`<html>`元素，我们称为**文档元素**。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在`HTML`页面中，文档元素始终都是`<html>`元素。在`XML`页面中，没有预定义的元素，因此任何元素都可能成为文档元素。

每一段标记都可以通过树种的一个节点来表示：`HTML`元素通过元素节点表示，特性（`attribute`）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有`12`种节点类型，这些类型都继承自一个基类型。

<pre>
Document
|
|--Element html
		|
		|--Element head
		|  		|
		|		|--Element title
		|				|
		|				|-Text Sapmle Page
		|
		|--Element body
				|
				|--ELement p
						|
						|--Text Hello World!
</pre>


##### 1.1 `Node`类型

`DOM``1`级定义了一个`Node`接口，该接口将由`DOM`中的所有节点类型实现。这个`Node`接口在`Javascript`中作为`Node`类型实现的；除了`IE`之外，在其他所有浏览器中都可以访问到这个类型。**`Javascript`中的所有节点类型都继承自`Node`类型**，因此所有节点类型都共享着相同的基本属性和方法。

每个节点都有一个`nodeType`属性，用于表明节点的类型。节点类型由在`Node`类型中定义的下列`12`个数值常量来表示。任何节点类型必居其一：

* `Node.ELEMENT_NODE;` --> 1
* `Node.ATTRIBUTE_NODE;` --> 2
* `Node.TEXT_NODE;` --> 3
* `Node.CDATA_SECTION_NODE;` --> 4
* `Node.ENTITY_REFERENCE_NODE;` --> 5
* `Node.ENTITY_NODE;` --> 6
* `Node.PROCESSING_INSTRUCTION_NODE;` --> 7
* `Node.COMMENT_NODE;` --> 8
* `Node.DOCUMENT_NODE;` --> 9
* `Node.DOCUMENT_TYPE_NODE;` --> 10
* `Node.DOCUMENT_FRAGMENT_NODE;` --> 11
* `Node.NOTATION_NODE;` --> 12

通常比较上面的这些常量，可以很容易地确定节点的类型，比如：

```javascript
// 在 IE 中无效
if (someNode.nodeType == Node.ELEMENT_NODE) {
	console.log(current node is an element.);
}
```

```javascript
// 适用于所有浏览器
if (someNode.nodeType == 1) {
	console.log(current node is an element.);
}
```
并不是所有节点类型都受到 `web` 浏览器的支持。开发人员**最常用的就是元素和文本节点**。

###### 1.1.1 `nodeName` 和 `nodeValue`属性

要了解节点的基本信息，可以使用`nodeName`和`nodeValue`这两个属性。这两个属性的值完全取决于节点的类型。在使用这两个值之前，最好先检测一下节点的类型。

```javascript
if (someNode.nodeType ==1){
	value = someNode.nodeName; // 元素的标签名 ==> "HTML","BODY","DIV" 这些
}
```

对于元素节点(`nodeType === 1`),`nodeName`始终是元素的标签名，而`nodeValue`始终是`null`。

###### 1.1.2 节点关系

文档中所有节点之间都存在这样或那样的关系。节点间的各种关系可以用传统的家族关系来描述，相当于把文档比喻成家谱。在`HTML`中，可以将`<body>`元素看成是`<html>`元素的子元素；相应地，也就可以将`<html>`元素看成是`<body>`元素的父元素。而`<head>`元素，则可以看成是`<body>`元素的同胞元素。

每个节点都有一个`childNodes`属性，其中保存着一个`NodeList`对象。`NodeList`是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。虽然可以通过方括号语法来访问`NodeList`的值，而且这个对象也有`length`属性，但它并不是`Array`的实例。`NodeList`对象的独特之处在于它实际上是基于`DOM`结构动态执行查询的结果，因此`DOM`结构的变化能够自动反映在`NodeList`对象中。我们常说，`NodeList`是有生命，有呼吸的对象，而不是在我们第一次访问它们的某个瞬间拍摄下来的快照。

```javascript
var firstChild = someNode.childNodes[0];
var firstChild2 = someNode.childNodes.item(0);

console.log(firstChild === firstChild2); // true
```

无论是使用方括号还是使用`item()`都没有问题。如同前面介绍，对`arguments`对象使用`Array.prototype.slice()`方法可以将其转换为数组。而采用通用的方法，也可以将`NodeList`对象转换成数组。如下：

```javascript
// IE8 及之前的版本中无效
var arr = Array.prototype.slice.call(childNodes,0);
```

`IE`8及之前的版本，需要通过手动枚举所有成员来转换。

```javascript
function convert2array(nodes){
	try{
		var arr = Array.prototype.slice.call(nodes,0);
	}catch(ex){
		var arr=[];
		var size = nodes.length;
		
		for (var i=0;i<size;i++){
			arr.push(nodes[i]);
		}
	}
	
	return arr;
}
```

每个节点都有一个`parentNode`属性，该属性指向文档树种的父节点。包含在`childNodes`列表中的所有节点都具有相同的父节点，因此它们的`parentNode`属性都指向同一个节点。此外，包含在`childNodes`列表中的每个节点相互之间都是同胞节点。通过使用列表中的每个节点的`previousSibling`属性和`nextSibling`属性，可以访问同一个列表中的其他节点。列表中的第一个节点的`previousSibling`的值为`null`，同样的，列表中最好一个节点的`nextSibling`属性的值也是`null`。

父节点与其第一个和最后一个子节点也存在特殊的关系。`parent.firstChild`始终等于`parent.childNodes[0]`，而`parent.lastChild` 始终等于 `parent.childNodes[parent.childNodes.length-1]`。

*所有节点都有的最后一个属性是`ownerDocument`，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多文档中。通过这个属性，我们可以不必在节点层次中通过层层回朔到达顶端，而是可以直接访问文档节点*。

###### 1.1.3 操作节点

因为关系指针都是只读的，所有`DOM`提供了一些操作节点的方法。其中最常用的方法是`appendChild()`，用于向`childNodes`列表的末尾添加一个节点。添加节点后，`childNodes`的新增节点、父节点及以前的最后一个节点的关系指针都会相应地得到更新。更新完成后，`appendChild()`返回新增的节点。

```javascript
var ret = someNode.appendChild(newNode);

console.log(ret === newNode === someNode.lastChild); // true
```
如果传入到`appendChild()`中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。即使可以将`DOM`树看成是由一系列指针连接起来的，但任何`DOM`节点也不能同时出现在文档中的多个位置上。因此，如果调用`appendChild()`时传入了父节点的第一个节点，那么该节点就会成为父节点的最后一个子节点。

如果需要把节点放在`childNodes`列表中某个特定的位置上，而不是放在末尾，那么可以使用`insertBefore()`方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（`previousSibling`），同时被方法返回。如果参照节点是`null`，则`insertBefore()`与`appendChild()`执行相同的操作。

```javascript
var ret = someNode.insertBefore(newNode,someNode.firstChild);
```

前面介绍的`appendChild()`和`insertBefore()`方法都只是插入节点，不会移除节点。`replaceChild()`方法接受两个参数：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。

```javascript
var ret = someNode.repleaceChild(newNode,someNode.firstChild);
```
在使用`replaceChild()`插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。尽管从技术上讲，被替换的节点仍然在文档中，但它在文档中已经没有了自己的位置。

如果只想移除而非替换节点，可以使用`removeChild()`方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。如下：

```javascript
var ret = someNode.removeChild(someNode.firstChild);
```

与`replaceChild()`方法一样，通过`removeChild()`移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。

*并不是所有的节点都在子节点，如果在不支持子节点的节点上面调用了这些方法，将会导致错误发生*。

###### 1.1.4

有两个方法是所有类型的节点都有的。第一个是`cloneNode()`，用于创建调用这个方法的节点的一个完全相同的副本。`cloneNode()`方法接受一个布尔值参数，表示是否执行深复制。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此这个节点副本就成为了一个“孤儿”，除非通过`appendChild()`,`insertBefore`,`replaceChild()`将它
添加到文档中。

然后是**`normalize()`**，这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或`DOM`操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。**当在某个节点上调用了这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并成一个文本节点**。

##### 1.2 `Document`类型

`JavaScript`通过`Document`类型表示文档。在浏览器中，`document`对象是`HTMLDocument`(继承自`Document`类型)的一个实例，表示整个`HTML`页面。

##### 1.3 `Element`类型
##### 1.4 `Text`类型
##### 1.5 `Comment`类型
##### 1.6 `CDATASection`类型
##### 1.7 `DocumentType`类型
##### 1.8 `DocumentFragment`类型
##### 1.9 `Attr`类型

------------------------

要不不做笔记了，就直接看，需要写代码的时候写代码，但是不写笔记了，如何？