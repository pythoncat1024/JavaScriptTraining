[TOC]
#### `JavaScript`读书笔记

##### 引用类型

引用类型的值（对象）是引用类型的一个实例。在`ECMAScript`中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被成为**类**，但是这种称呼并不妥当。尽管`ECMAScript`从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为**对象定义**，因为它们描述的是一类对象所具有的属性和方法。

##### 1.x `Object`类型

###### 1.1.x `Object`类型对象的创建方式有两种：
	
* 第一种是使用`new`操作符后跟`Object`构造函数，如下所示：

```javascript
var person = new Object();
person.name = 'Stone';
person.age = 29;
```

* 第二种是使用**对象字面量**表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。如下所示：

```javascript
var person = {
	name:"Stone",
	age:29
};
```

> 使用字面量表示法更常见。

```javascript
function displayInfo(args) {
    var info = "";
    if (typeof args.name === "string") {
        info += "Name: " + args.name;
    }
    if (typeof args.age === "number") {
        info += "Age: " + args.age;
    }

    console.log("arg===>" + info);
}

displayInfo({name: "张飞", age: 33}); // 参数传入一个对象
displayInfo({name: "王菲"});
displayInfo({name: "北条麻妃", age: 38, "job": "actress"});

```

###### 1.2.x 访问对象属性的两种方式：

> `obj.attr `和 `obj["attr"]`，如下所示：

```javascript
var slave = {"first name": "stone", "last name": "Jack", "age": 22};

console.log(slave['first name'] + " , " + slave.age);
```
> 对于有特殊字符的属性，只能通过`obj["attr"]`的方式访问了。

##### 2.x `Array`类型

`ECMAScript`数组与其他语言中的数组都是数据的有序列表，但是与其他语言不同的是，`ECMAScript`数据的每一项可以保存任何类型的数据。而且`ECMAScript`数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。

###### 2.1.x `Array`类型对象创建方式有两种：

* 第一种，通过`new`操作符与`Array`的构造函数来创建：

```
var arr1 = new Array(); // 创建一个空的数组

var arr2 = new Array(3); // 创建一个 length 值为 3 的数组
//  这种创建方式，里面有 3 个元素，每个的值都是 undefined。

var arr3 = new Array("star","shit"); // 创建一个包含两个字符串的数组
```
> 另外，使用这种方式创建数组，`new`操作符也可以省略。

```javascript
var tom = Array("rose","victor");
```

* 第二种，使用数组字面量表示法。如下所示：

```javascript
var colors = ['red','blue','green'];
var names = [];
var values = [1,2,3,]; // todo: 不要这样！这样会创建一个包含3项或4项的数组
var options = [,,,]; // todo: 不要这样！这样会创建一个包含3项或4项的数组
```

###### 2.2.x 读取和设置数组的值
> 要使用方括号并提供相应值的基于`0`的数字索引，如下所示：

```
var colors = ["red", "green", "blue"];
console.log(colors[0]); // 读取值
colors[1] = "yellow";   // 设置值
colors[2] = "black";
```
**数组的`length`属性不是只读的**。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。如下所示：

```javascript
var colors = ["red", "blue", "green"];
colors.length = 2; // 原本是3的
console.log(colors[2]); // undefined

colors[colors.length] = "pink"; // 末尾添加一个元素
colors[colors.length] = "gray"; // 末尾再添加一个元素
```

数组的骚操作：

```javascript
var colors = ["red" , "blue" , "green"];

colors[99] = "pink";
console.log(colors.length); // 100
```

通过这种方式也可以跳跃的给数组添加元素，在`[2]-[99]`之间的元素未定义，所以访问它们，返回的都是`undefined`。

###### 2.3.x 判断一个对象是不是数组类型

```
if (value isinstanceof Array){
	// do something
}
```

**`instanceof`操作符的问题在于，它假设单一的全局执行环境**。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的`Array`构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

**为了解决这个问题，`ECMAScript5`新增了 `Array.isArray()`方法**。这个方法的
目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。
```
if (Array.isArray(value)){
	// do something
} // 这种判断方式更好
```

###### 2.4.x 转换方法

每个对象都包含`toString(),toLocaleString(),valueof()`方法。

```
var colors = ["red", "green" , "blue"];
console.log(colors); // red,green,blue
console.log(colors.toString()); // red,green,blue
console.log(colors.join("|")); // red|green|blue
```
###### 2.5.x 栈方法

栈是一种`LIFO`(last in first out)的数据结构。也就是**最新添加的项最早被移除。**而栈中项的插入（叫做**推入**）和移除（叫做**弹出**），只发生在一个位置--栈的顶部。`ECMAScript`为数组专门提供了`push()`和`pop()`方法，以便实现类似栈的行为。
**`push()`方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而`pop()`方法则从数组的末尾移除最后一项，减少数组的`length`值，然后返回移除的项**。如下所示：

```javascript
var colors = new Array();
var count = colors.push("red","blue");
console.log(count); // 2
count = colors.push("pink");
console.log(count); // 1
var item = colors.pop();
console.log(item); // pink
```

###### 2.6.x 队列方法

栈数据结构的访问规则是`LIFO`(后进先出)，而队列数据结构的访问规则是`FIFO`（first in first out 先进先出）。**队列在列表的末端添加项，从列表的前端移除项**。由于`push()`方法是向数组的末端添加项的方法，因此要模拟队列只需一个从数组前端取出项的方法。实现这一操作的数组方式就是`shift()`，它能够移除数组的第一个项并返回该项，同时将数组的长度-1.**结合使用 `shift()`和`push()`方法，就可以像使用队列一样使用数组**。

* 反向队列

`ECMAScript`还为数组提供了一个`unshift()`方法。`unshift()`方法与`shift()`的用途相反：它能在数组的前端添加任意个项并返回新数组的长度。因此，**同时使用 `unshift()`和`pop()`方法，可以从相反飞方法来模拟队列，即在数组的前端添加项，从数组的末端移除项**。

###### 2.7.x 重排序方法

数组中已经存在两个可以直接用来重排序的方法：`reverse()`和`sort()`。

> `reverse()`方法用于反转数组。
> 默认情况下，`sort()`方法按升序排列数组项--即，最小值在最前面，最大值在最后面。*为了实现排序，`sort()`方法会调用每个数组项的`toString()`转型方法，然后比较得到的字符串，以确定如何排序。即使数组的每一项都是数值，`sort()方法比较的也是字符串`*。

```javascript
var values = [0 ,1 , 5, 10 ,15];
values.sort();

console.log(values); // 0,1,10,15,5
```

***sort()方法可以接受一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面***

> 比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。如下所示：

```

var stu1 = {
    name: "python", age: 80, grade: 99,
    toString: function () {
        return this.name + " , " + this.age + " , " + this.grade;
    }
};
var stu2 = {
    name: "javascript", age: 30, grade: 88, toString: function () {
        return this.name + " , " + this.age + " , " + this.grade;
    }
};
var stu3 = {
    name: "php", age: 18, grade: 59, toString: function () {
        return this.name + " , " + this.age + " , " + this.grade;
    }
};
var stu4 = {
    name: "vb", age: 50, grade: 70, toString: function () {
        return this.name + " , " + this.age + " , " + this.grade;
    }
};
var stu5 = {
    name: "shell", age: 60, grade: 70, toString: function () {
        return this.name + " , " + this.age + " , " + this.grade;
    }
};
var stu6 = {
    name: "java", age: 40, grade: 99, toString: function () {
        return this.name + " , " + this.age + " , " + this.grade;
    }
};

var langArr = [stu1, stu2, stu3, stu4, stu5, stu6];

console.log("排序前：" + langArr);
console.log("-------------------");


function compare(a, b) {
    if (a.grade > b.grade) {
        return -5;
    } else if (a.grade === b.grade) {
        return 0;
    } else {
        return 5;
    }
} // todo:简单排序，仅仅通过分数进行排序

function cmp(a, b) {

    if (a.grade > b.grade) {
        return -5;
    } else if (a.grade === b.grade) {
        // return 0;
        if (a.age < b.age) {
            return -4;
        } else if (a.age === b.age) {
            return a.name.localeCompare(b.name);
        } else {
            return 4;
        }
    } else {
        return 5;
    }
} // todo:复杂排序，先比较分数，然后是年龄，最后是名字字符串

// langArr.sort(compare);
langArr.sort(cmp);

console.log("排序后：" + langArr);

```

###### 2.8.x 操作方法

`ECMAScript`为操作已经包含在数组中的项提供了很多方法。
	
* 其中，`concat()`方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组，在没有给`concat()`方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给`concat()`方法的是一个或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会简单地被添加到结果数组的末尾。如下所示：

```javascript
var colors = ["red" , "green" , "blue" ];

var colors2 = colors.concat("pink" , ["white" , "black"]);

console.log(colors2.toString()); // red,green,blue,pink,white,black
```

* 然后是`slice()`方法。它能够基于当前数组中的一个或多个项创建一个新的**数组**。`slice()`方法可以接受一个或两个参数，即要返回项的起始和结束位置。但是在只有一个参数的情况下，`slice()`方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项--但是不包括结束位置的项。注意，`slice()`方法不会影响原来的数组。如下所示：

```javascript
var colors = ["red" , "green" , "blue" ];
var another = colors.slice(0,1);
var demo = colors.slice(1);

console.log(another.toString()); // red -->实际是 ['red'];
console.log(demo.toString()); // green,blue
```
> 如果`slice()`方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含`5`项的数组上调用`slice(-2,-1)`与调用`slice(5-2,5-1)`得到的结果相同。如果结束位置小于起始位置，则返回空数组。

* **强大的`splice()`方法**

***注意：这个方法和之前的`concat() , slice()`不同的是，这个方法是原地修改，修改当前数组，而不是产生一个副本！！！！***

> 该方法的返回值是由被删除的项组成的数组。

它有很多种用法。`splice()`的主要用途是向数组的中部插入项，但是使用这种方法的方式则有`3`种。

> 删除：可以删除任意数量的项，只需指定`2`个参数：要删除的第一项的位置和要删除的项数。例如，`splice(0,2)`会删除数组中的前两项。

> 插入：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四个，第五个以至任意多个项目。例如，`splice(2,0,"red","green")`会从当前数组的位置2开始插入字符串`"red"`和`"green"`.

> 替换：可以像指定位置插入任意数量的项，且同时可以删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如：`splice(2,1,"red","green")`会删除当前数组位置`2`的项，然后再从位置2开始插入字符串`"red"`和`"green"`。

`splice()`方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。
```
var names=["python","php","perl","pascal"];
var another = names.splice(1,2,"java");
console.log(names+" ### "+another +" >>> "+(another instanceof Array));
```
> 输出如下：
```
python,java,pascal ### php,perl >>> true
```

从输出可以看到，将原数组的元素从`index=1`开始，删除了`2`个元素，并且，在`index=1`的位置插入了新的元素`"java"`。

-<>- 从`index=1`开始删除`2`个元素，然后在`index=1`的位置，插入`"java","javascript","golang","shell"`这几个元素。

```
var names=["python","php","perl","pascal"];
var another = names.splice(1,2,"java","javascript","golang","shell");
console.log(names+"");
```
> 输出如下：
```
python,java,javascript,golang,shell,pascal
```

* 位置方法

`ECMAScript5`为数组实例添加了两个位置方法：`indexOf()`和`lastIndexOf()`。这两个方法都接收两个参数：要查找的项和（可选的）表示找起点位置的索引。

这两个方法都返回要查找的项在数组中的位置，或者没有找到的情况下返回`-1`。**在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等(就像使用`===`一样)。.**

```javascript
var names = ["python" , "golang" , "php" , "shell" , "java" ];
var posShell = names.indexOf("shell"); // 字符串是基本类型，所以可以全等
var posPhp = names.indexOf("php",3); 

console.log("shell=="+posShll +" , php==" +posPhp);

var person = { name:"Tom" , age:13 };
var people = [person];
var morePeople = [{name:"Tom" , age:13 }];

console.log(people.lastIndexOf(person)+" , "+morePeople.indexOf(person));
```

> 输出如下：

```
shell==3 , php==-1
0 , -1
```
> 为什么 `php===-1` ？因为是从`index=3`开始查找，后面没有`"php"`了。
> 为什么最后一个输出是-1 ？因为两个数值相同的对象并不是同一个对象，并不全等。

* 迭代方法

`ECMAScript`为数组定义了`5`个迭代方法。每个方法都接收两个参数：要再每一项上运行的函数和（可选的）运行该函数的作用域对象--影响`this`的值。**传入这些方法中的函数会接收三个参数：**数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。以下是这`5`个迭代方法的作用。

 -- `every()`: 对数组中的每一项运行给定的函数，如果该函数的对每一项都返回`true`，则返回`true`。
 
 -- `filter()`: 对数组中的每一项运行给定的函数，返回该函数会返回`true`的项组成的数组。
 
 -- `forEach()`: 对数组中的每一项运行给定的函数，这个方法没有返回值。
 
 -- `map()`: 对数组中的每一项运行给定的函数，返回每次函数调用的结果组成的数组。
 
 -- `some()`: 对数组中的每一项运行给定的函数，如果该函数对任一项返回`true`，则返回`true`。


```
var names = ["php" , 33 , "python" , "java" , "shell" , "golang" , 77];

function isString(item,index,array){
	return (typeof item === "string")
}

function plus(item,index,array){
	return item +"{#}";
}

console.log( names.map(plus) );

console.log( names.every(isString) );

names.forEach(console.log); // 打印 item,index, array |-->(其中item,index在不断next)
```

* 缩小方法

`ECMAScript5`还新增了两个缩小数组的方法：`reduce()`和`reduceRight()`。

#### todo:

##### 3.x `Date`类型

`ECMAScript`中的`Date`类型是在早期`Java`中的`java.util.Date`类基础上构建的。为此，`Date`类型使用自`UTC`(Coordinated Universal Time, 国际标准时间) `1970`年`1`月`1`日午夜(零时)开始经过的毫秒值来保持日期。在使用这种数据存储格式的条件下，`Date`类型保存的日期能够精确到`1970`年`1`月`1`日之前或之后的`285 616`年。

`var now = new Date();`  // Date

`var day = Date.parse("formatStr");`

> `Date.parse(str);`解析的字符串如果不是一个时间字符串，会返回`NAN`;否则返回对应的毫秒值。

`var seconds = Date.UTC(2016,6,16,8,17,25);` 注意，这里的月份是基于`0`的。

`var now = Date.now();` // number

##### 4.x `RegExp`类型

`ECMAScript`通过`RegExp`类型来支持正则表达式。使用下面类似`Perl`语法，就可以创建一个正则表达式。

`var expression = / pattern / flags ;`

其中的模式（`pattern`）部分可以是任何简单或者复杂的正则表达式，可以包含字符串类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一个或多个标志（`flag`），用以标明正则表达式的行为。
	
	-- `g`:`global`
	
	-- `i` `ignore`忽略大小写
	
	-- `m` `multiline` 多行文本
	
正则表达式中的元字符必须转义，元字符有：`( [ { \ ^ $ | ) ? * + . ] }`

`var pat = /at/gi;`


`var pat = new RegExp("at","gi");` // 效果与上面的相同

```
var pat = /at/gi;
var check = pat instanceof RegExp;
// 输出：true
```

* `RegExp`实例属性

-- `global`: 布尔值，表示是否设置了`g`标志。

-- `ignoreCase`: 布尔值，表示是否设置了`i`标志。

-- `lastIndex`: 整数，表示开始搜索下一项的字符串位置，从`0`算起。

-- `multiline`: 布尔值，表示是否设置了`m`标志。

-- `source`: 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

* `RegExp`实例方法

`RegExp`对象的主要方法是`exec()`，该方法是专门为捕获组而设计的。`exec()`接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回`null`。返回的数组虽然是`Array`的实例，但包含两个额外的属性：`index`和`input`。其中，`index`表示匹配项在字符串中的位置，而`input`表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。如下所示：

```javascript
var text = "mon and dad an baby";
var pattern = /mon( and dad( and baby)?)?/gi;
var matchs = pattern.exec(text);
```

`RegExp`对象的第二个方法是`test()`，它接受一个字符串参数。在模式与该参数匹配的情况下返回`true`；否则，返回`false`。

```javascript
var text = "000-00-0000";
var pattern = /\d{3}-\d{2}-[0-9]{4}/;

var match = pattern.test(text);

console.log(match); // true
```

##### 5.x `Function`类型

`ECMAScript`中的函数实际上是对象。每个函数都是`Function`类型的实例，而且都与其他引用类型一样具有属性和方法。*由于函数是对象，因此函数名实际上是一个指向函数对象的指针，不会与某个函数绑定。***函数通常是使用函数声明的语法定义的，如下所示**：

```javascript
function sum(num1,num2) {
	return num1 + num2;
}
```
这与下面**使用函数表达式定义函数的方式**几乎相差无几。

```javascript
var sum = function(num1 , num2){
	return num1 + num2;
};
```

> 注意：第二种方式定义函数，`}`后面需要添加`;`表示结束，就像定义其他变量时一样。

最后，也可以通过使用`Function`构造函数来定义函数。`Function`构造函数可以接收任意数量的参数，**但是最后一个参数始终被看成是函数体*，而前面的参数则枚举了新函数的参数。如下：

```javascript
var sum = new Function("num1" , "num2" , "returun num1  + num2"); // 不推荐
```

*从技术角度讲，这是一个函数表达式。但是，不推荐，因为这种语法会导致解析两次代码（第一次是解析常规的`ECMAScript`代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。.*


> 由于函数名是指针，所以函数名和其他变量没有什么不同，一个函数可以有多个名字：

```javascript
var sum = function(num1 , num2){
	return num1 + num2;
}

var another = sum; // 再来一个函数名

console.log(another(1,1)); 
```

* **!important**:没有重载（深入理解）

将函数名想象为指针，也有助于理解为什么`ECMAScript`中没有*函数重载*的概念。

如下代码：

```javascript
function add(num){
	return num + 100;
}
function add(num){
	return num + 200;
}
```

其实等效于下面的写法：

```javascript
var add = function(num){
	return num + 100;
}

add = function(num){
	return num + 200;
}

```

从第二中写法可以明显看出，这种操作会导致后面的函数覆盖了前面的函数。-**-在创建第二个函数时，实际上覆盖了引用第一个函数的变量`add`。.**

* 函数声明与函数表达式

函数声明与函数表达式没有什么本质的区别。但是，**解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。**

> 使用函数声明，代码正常运行

```javascript
console.log(sum(1+2));

function sum(num1 , num2){
	return num1 +  num2;
}
```
<-> 以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为**函数声明提升**（`function declaration hoisting`）的过程，读取并将该函数声明添加到执行环境中。对代码求值时，`JavaScript`引擎在第一遍会声明函数并将它们放在源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，`JavaScript`引擎也能把函数声明提升到顶部。

> 使用函数表达式，代码报错！

```javascript
console.log(sum(1+2));

var sum = function(num1 , num2){
	return num1 + num2;
}
```

以下是在测试代码：

```javascript


console.log(sum(1, 1)); // 输出为 2 
function sum(a, b) {

    return a + b;
}


console.log(add(3, 4));  // 这里会报错：TypeError: add is not a function

var add = function (a, c) {
    return a + c;
};
```

* 作为值的函数

因为在`ECMAScript`中，函数名本身就是变量，所以函数也可以作为值在使用。也就是说，**不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。**

* 函数内部属性

在函数内部，有两个特殊的对象：`arguments`和`this`。其中，`arguments`是一个类数组对象，包含着传入函数中的所有参数。虽然`arguments`的主要用途是保存函数参数，但这个对象还有一个名叫`callee`的属性，该属性是一个指针，指向拥有这个`arguments`对象的函数。如下阶乘函数中，就有对该属性的使用：

```javascript


function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * factorial(num - 1);
    }
} // 耦合性强，内部的函数名被指定了

function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);  
        // 使用 arguments.callee 指针
    }
} // 解除这种耦合
```

`ECMAScript`中的`this`对象和`Java`、`C#`中的`this`对象大体相似。换句话说，`this`引用的是函数据以执行的环境对象--或者也可以说是`this`值（当在网页的全局作用域中调用函数时，`this`对象引用的就是`window`）。如下所示：

```javascript
color1 = "red";

function printColor() {

    console.log(this.color1);
}

var obj = {color1: "black"};

printColor(); // red         # 这里的this 就是 window 对象

obj.printColor = printColor;
obj.printColor(); // black   # 这里的this 就是 obj 对象
```
`ECMAScript5`规范了另一个函数对象的属性：`caller`。这个属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为`null`。如下所示：

```

function outer() {
    console.log(arguments.callee.caller);
    inner();
}

function inner() {
    console.log(arguments.callee.caller);
}

outer(); // 输出 null , outer

var obj = {};

obj.inner = inner;

obj.inner();  // 输出  null 
```

> 概括来说就是，如果当前函数被另一个函数调用，当前函数的`caller`是调用的函数对象引用；当前函数被非函数的对象调用（比如这里定义的`obj`，或者全局的`window`），当前函数的`caller`为`null`!

*探索`this`，`callee`与`caller`*

a. 单层调用

```javascript
// 在 网页执行：
function outer() {
    // inner();
    console.log("arguments.callee==[" + arguments.callee + "] , this==[" + this + "] , caller==[" + arguments.callee.caller + "]");
}

function inner() {
    console.log("arguments.callee==[" + arguments.callee + "] , this==[" + this + "] , caller==[" + arguments.callee.caller + "]");
}

outer();

```
> 输出如下：

```
arguments.callee==[function outer() {
    // inner();
    console.log("arguments.callee==[" + arguments.callee + "] , this==[" + this + "] , caller==[" + arguments.callee.caller + "]");
}] , this==[[object Window]] , caller==[null]

```
> 也就是说，在网页执行上述代码，函数的上述三个属性分别是：

```
当前函数(arguments.callee)：
function outer() {
    // inner();
    console.log("arguments.callee==[" + arguments.callee + "] , this==[" + this + "] , caller==[" + arguments.callee.caller + "]");
}
-------
this对象：
[object Window]
-------
调用当前函数的函数对象（caller）：
null
-------
```

b. 函数调用函数

```javascript
// 在网页中执行
function outer() {
    inner();
}

function inner() {
    console.log("arguments.callee==[" + arguments.callee + "] , this==[" + this + "] , caller==[" + arguments.callee.caller + "]");
}

outer();
```
> 输出如下：

```
arguments.callee==[function inner() {
    console.log("arguments.callee==[" + arguments.callee + "] , this==[" + this + "] , caller==[" + arguments.callee.caller + "]");
}] , this==[[object Window]] , caller==[function outer() {
    inner();
}]
```
> 函数中调用函数时，被调用函数的三个属性分别是：

```
当前函数(arguments.callee)：
function inner() {
    console.log("arguments.callee==[" + arguments.callee + "] , this==[" + this + "] , caller==[" + arguments.callee.caller + "]");
}
-------
this对象：
[object Window]
-------
调用当前函数的函数对象(caller):
function outer() {
    inner();
}
-------

```

**从两次验证可以看出：**

	- `this`属性不受函数的调用层级的影响，表示的总是当前执行环境对象。
	- `arguments.callee`属性表示的总是当前函数对象。
	- `arguments.callee.caller`属性 表示的总是调用当前函数的函数对象，如果当前当前函数不是被函数调用，该值为`null`。

> 严格模式下：不能访问`arguments.callee`和`arguments.callee.caller`。

**每个函数都包含两个非继承而来的方法：`apply()`和`call()`**。这两个方法的用途是在特定的作用域中调用函数，实际上等于设置函数体内的`this`对象的值。

首先，`apply()`方法接收两个参数：一个是其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是`Array`实例，也可以是`arguments`对象。如下：

```javascript
function sum(num1 , num2) {
	return num1 + num2 ;
}

sum.apply(this,[1,2]);

function callSum(num1 , num2){
	return sum.apply(this,arguments);
}

```

> `apply()`方法的实际应用场景1：

```javascript
var numbers = [2, 1, 3, 6, 4, 5, 7, 0];
var max = Math.max.apply(Math, numbers);
console.log(max);
// ------ apply 的第一个参数其实可以是任意对象，因为这个对象被当做是 Math.max()函数的this 对象，
// 也就是当前函数的执行环境对象。在网页全局执行，应该就是window对象

var max = Math.max.apply({}, numbers); // 比如这里直接写了一个字面量对象 {}
console.log(max);

```

`call()`方法与`apply()`方法类似，只是参数不同，第一个参数依然是其中运行函数的作用域，其余的参数都直接传递给函数。换句话说，在使用`call()`方法时，传递给函数的参数必须逐个列举出来。如下：

```javascript
function sum (num1 , num2){
	return num1 + num2 ;
}

sum.call(this,1,2);

sum.call(this,4,5);
```

> *`apply()`和`call()`的主要用途是扩展函数的赖以运行的作用域。.*如下：
 
```javascript
var red = {color: "red"};
var black = {color: "black"};

function printColor() {
    console.log(this.color); // 注意，这里用到了this
}

printColor.call(red);
// 输出 RED
printColor.call(black);
// 输出 BLACK

```

函数的`bind()`方法。这个方法会创建一个函数实例，其`this`值会绑定到传给`bind()`函数的值。如下：

```javascript
color = "red";
var obj = {color:"blue"};
function sayColor(){
	return this.color;
}

anotherSay = sayColor.bind(obj);

anotherSay(); // blue
sayColor(); // red
```

##### 6.x 基本包装类型(`Number`,`String`,`Boolean`)

`Object`构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。

```javascript
var obj = new Object("some text");
alert(obj instanceof String); // true
```

注意：转型函数会返回基本类型的数据，而使用`new`调用构造函数，会返回一个对象。

```javascript
var value = "25";
var num = Number(value);  // 转型函数
console.log(typeof num); // "number"

var obj = new Number(value); // 构造函数
console.log(typeof obj); // "object"
```

`Boolean`

`Number`

`String`

字符串的操作方法：

```
var str="some text";
var s = str[0]; // "s"

str.charAt(2); // "m"

str.charCodeAt(2); // 109

str.concat(" good"); // some text good

```

`Math`对象的使用：选择随机颜色

```javascript
var colors = ["red", "blue", "green", "black", "white", "gray", "pink", "yellow"];

function chooseRandom(colors) {
    var index = Math.floor(Math.random() * colors.length);
    return colors[index];
}
console.log(chooseRandom(colors));
```

##### 7.x 小结

对象在`Javascript`中被成为**引用类型**的值，而且有一些内置的引用类型可以用来创建特定的对象。

* 引用类型与传统面向对象程序设计中的类相似，但实现不同；
* `Object`是一个基础类型，其他所有类型都从`Object`继承了基本行为；
* `Array`类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；
* `Date`类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
* `RegExp`类型是`ECMAScript`支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。
* 函数实际上是`Function`类型的实例，因此函数也是对象。所有函数也拥有方法，可以增强其行为；
* 因为有*基本包装类型*，所以`Javascript`中基本类型的值可以被当做对象来访问。三种基本包装类型分别是：`Boolean`,`Number`,`String`。
	* 每个包装类型都映射到同名的基本类型；
	* 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作；
	* 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。
* **在所以代码执行之前，作用域中就已经存在了两个内置对象：`Global`和`Math`**。在大多数`ECMAScript`实现中都不能直接访问`Global`对象；不过，`Web`浏览器实现了承担该角色的`window`对象。全局变量和函数都是`Global`对象的属性。`Math`对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。 	
