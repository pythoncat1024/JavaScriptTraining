## `JavaScript`读书笔记

> 备注：为了防止标签错乱，现在规定，标题用 `##` ，一级标题是`###` ， 二级是`####` ， 三级是 `#####`。

### 面向对象的程序设计

内容（3点）：
> 理解对象属性
> 
> 理解并创建对象
> 
> 理解继承

面向对象（`Object-Oriented`,`OO`）的语言有一个标志，那就是他们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。前面提过，`ECMAScript`中没有类的概念，因此它的对象也与基于类的语言的对象有所不同。
`ECMA-262`把对象定义为：**“无序属性的集合，其属性可以包含基本值、对象或者函数。”**严格来讲，这就相当于说对象是一组没有特点顺序的值。对象的每个属性或者方法都有一个名字，而每个名字都映射到一个值。正因为这样，我们可以把`ECMAScript`的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。

每个对象都是基于引用类型创建的，这个引用类型可以是原生类型，也可以是自定义的类型。

#### 1 理解对象

创建一个自定义对象的简单方式：

```javascript
var person = new Object();
person.name = 'Luna';
person.age = 29;
person.job = "software engineer";

person.sayName = function(){
	console.log(this.name);
	// 这里的 this 就是 person 对象
}
```
使用字面量表示法：

```javascript
var person = {
	name : 'Luna',
	age : 29,
	job : 'software engineer',
	sayName : function() {
		console.log(this.name);
	}
};
```

两种方式创建的`person`对象是一样的，都有相同的属性和方法。这些属性在创建时都带有一些特征值(`characteristic`)，`Javascript`通过这些特征值来定义它们的行为。

##### 1.1 属性类型

`ECMAScript`中有两种属性：数据属性和访问器属性。

###### 01 数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。

* `[[Configrable]]`: 表示能否通过`delete`删除属性从而重写定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为`true`。
* `[[Enumerable]]`: 表示能否通过`for-in`循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为`true`。
* `[[Writable]]`: 表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为`true`。
* `[[Value]]`: 包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为`undefined`。

要修改属性默认的特性，必须使用`ECMAScript5`的`Object.defineProperty()`方法。这个方法接收三个参数：属性所在的对象，属性的名字和一个描述符对象。其中描述符（`descriptor`）对象的属性必须是：`configurable`、`enumerable`、`writable`、`value`。设置其中一个或者多个值，可以修改对象的特征值。如下:

> 修改对象的 `value`和`writeable`属性：

```javascript
var person = {
	name : 'Luna'
};

var desc = {
	value : 18,
	writeable : false
};

Object.defineProperty(person,"age",desc);
person.age = 30;

console.log(person.age);
```
> `Object.defineProperty()`方法，在多数情况下都不需要使用。

###### 02 访问器属性

访问器属性不包含数据值；它们包含一对儿`getter`和`setter`函数。（不过，这两个函数都不是必须的）。在读取访问器属性时，会调用`getter`函数，这个函数负责返回有效的值；在写入访问器属性时，会调用`setter`函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。

* `[[Configurable]]`: 表示能否通过`delete`删除属性从而重写定义属性，这个特性的默认值为`true`。
* `[[Enumrable]]`: 表示能否通过`for-in`循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为`true`。
* `[[Get]]`: 在读取属性时调用的函数，默认值为`undefined`。
* `[[Set]]`: 在写入属性时调用的函数。默认值为`undefined`。

访问器属性不能直接定义，必须使用`Object.defineProperty()`来定义。如下示例：

```javascript
var book = {
    _year: 2004,
    edition: 1
};
book.price = 1024.4;

// 定义访问器属性 year
Object.defineProperty(book, "year", {
    set: function (val) {
        this._year = val;
        if (val > 2004) {
            this.edition += val - 2004;
        }
    },
    get: function () {
        return this._year;
    }
    // ,enumerable: true  // 加上这句就可以输出 year 属性
});

book.year = 2018; // 定义完成就可以调用 该属性了
console.log(book.year + " , " + book.edition);

book._year = 2028;
console.log(book._year + " , " + book.edition);


for (var prop in book) {
    console.log("prop: " + prop); 
    // 并不会输出 year 这个属性
}
```

以上代码创建了一个`book`对象，并给它定义了两个默认属性：`_year`,`edition`。`_year`前面的下划线是一种常用的记号，用来表示只能通过对象方法访问的属性。而访问器属性`year`则包含一个`getter`函数和一个`setter`函数。`getter`函数返回`_year`的值，`setter`函数通过计算来确定正确的版本。因此把`year`属性修改为`2018`会导致`_year`变成`2018`，而`edtion`变成`15`。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。

> 不一定要同时指定`getter`和`setter`。严格模式下，需要同时指定。

##### 1.2 定义多个属性

由于为对象定义多个属性的可能性很大，`ECMAScript5`又定义了一个`Object.defineProperties()`方法。利用这个方法可以通过描述符一次性定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。如下：

```javascript
/**
 * Created by cat on 2018/4/21.
 */

var book = {};

var props = {
    _year: {
        value: 2004
        , enumerable: true
    },
    edition: {
        value: 1
        // , enumerable: true
    },
    year: {
        set: function (val) {
            this._year = val;
            if (val > 2004) {
                this.edition += val - 2004;
            }
        },
        get: function () {
            return this._year
        }
        , enumerable: true
    }
};

console.log(props + " ### " + typeof props + " , " + Boolean(props));
Object.defineProperties(book, props);


for (var prop in book) {
    console.log(prop, book[prop]);
}
```

> 上述代码给`book`对象添加了`_year`,`year`,`edition`，这三个属性。并设置`_year`与`year`属性是可枚举的（可以通过对对象执行`for-in`语句返回对应的属性）。

--

> TIPS: *给属性前面加`_`成为`_year`只是不希望外部直接访问，并不是说外部不能直接访问!*

##### 1.3 读取属性的特性

使用`ECMAScript5`的`Object.getOwnPropertyDescriptor()`方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要去读其描述符的属性的名称。返回值是一个对象。*如果是数据属性，这个对象的属性有`configurable`,`enumerable`,`writeable`,`value`*；*如果是访问器属性，这个对象的属性有`configurable`,`enumerable`,`get`,`set`*。

```javascript

var descriptor = Object.getOwnPropertyDescriptor(book,"_year");
// 遍历描述符对象，读取其属性
for(prop in descriptor){
    console.log(prop, descriptor[prop]);
}
```
> 数据属性返回（这里是`_year`属性）：

```
value 2004
writable false
enumerable true
configurable false
```

> 访问器属性的描述符中有（这里是`year`属性）：

```
get function () {
            return this._year
        }
set function (val) {
            this._year = val;
            if (val > 2004) {
                this.edition += val - 2004;
            }
        }
enumerable true
configurable false
```

#### 2 创建对象

虽然`Object`构造函数或者对象字面量都可以创建单个对象，但是这个方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这个问题，人们开始使用工厂模式的的一种变体。

##### 2.1 工厂模式

```javascript
function createPerson(name,age,job){
	var person = {};
	person.name = name;
	person.age = age;
	person.job = job;
	person.sayName = function(){
		console.log(person.name);
	}
	
	return person;
}

console.log(a.valueOf());
console.log(b.valueOf());

console.log(a instanceof Object);
```
> 但是这个方法也要一个缺点，就是不知道创建的这个对象的具体类型，只知道是一个`Obejct`类型。（没有解决对象识别问题）

##### 2.2 构造函数模式

**`ECMAScript`中构造函数可以用来创建特定类型的对象**。像`Object`和`Array`这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写。如下：

```javascript
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        return this.name;
    };
}

var p1 = new Person("Ann" , 23 , "actress");
var p2 = new Person("Rose" , 23 , "writer");
```

这种方式和上一种(`createPerson()`)，有一些不同之处：

* 没有显式地创建对象；
* 直接将属性值赋给了`this`对象； **提问：这里的this是什么，是window 吗？**
* 没有return语句。

此外，函数名`Person`首字母大写，这是构造函数的惯例。（*非必须，是推荐方式*）主要目的是区分构造函数和`ECMAScript`中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。

**要创建`Person`的新实例，必须使用`new`操作符**。以这种方式调用构造函数，实际上会经历以下`4`个步骤：

1. **创建一个新的对象**；
2. **将构造函数的作用域赋给新对象（因此 `this` 就指向了这个新对象）**；
3. **执行构造函数中的代码（为这个新对象添加属性）**；
4. **返回新对象**。


*质疑：构造函数与普通函数有什么区别，调用构造函数创建对象必须使用`new`操作符吗？能不能省略`new`？*

--- 通过比较`this`对象来查看区别。

> 1 使用`new`调用构造函数的代码：

```javascript
console.log("<>>>before this是 Window 类型吗？ " + (this instanceof Window));
function Person(name, age, job) {
    console.log("inner this是 Window 类型吗？ " + (this instanceof Window));
    console.log("inner this是 Person 类型吗？ " + (this instanceof Person));
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        return this.name;
    };
}
var p1 = new Person("Ann", 23, "actress"); 
// todo: 使用了 new 操作符
console.log("outer this是 Window 类型吗？ " + (this instanceof Window));
console.log("outer this是 Person 类型吗？ " + (this instanceof Person));

// 在浏览器运行的输出结果如下

/**
 <pre>
 // todo: 在浏览器运行的输出结果如下 :
 <>>>before this是 Window 类型吗？ true
 inner this是 Window 类型吗？ false
 inner this是 Person 类型吗？ true
 outer this是 Window 类型吗？ true
 outer this是 Person 类型吗？ false
 </pre>
 */

```
> 2 不使用`new`，直接调用构造函数的代码：

```javascript
console.log("<>>>before this是 Window 类型吗？ " + (this instanceof Window));
function Person(name, age, job) {
    console.log("inner this是 Window 类型吗？ " + (this instanceof Window));
    console.log("inner this是 Person 类型吗？ " + (this instanceof Person));
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        return this.name;
    };
}
var p1 = Person("Ann", 23, "actress"); // 注意：这里没有 new
console.log("outer this是 Window 类型吗？ " + (this instanceof Window));
console.log("outer this是 Person 类型吗？ " + (this instanceof Person));

/*
 <pre>
 // todo: 在浏览器运行的输出结果如下 :
 <>>>before this是 Window 类型吗？ true
 inner this是 Window 类型吗？ true
 inner this是 Person 类型吗？ false
 outer this是 Window 类型吗？ true
 outer this是 Person 类型吗？ false
 </pre>
 */
```

同样的代码，只是在调用的时候，一次使用了`new`操作符来调用`Person()`函数，一次没有。然后输出的效果并不相同。
从`log`可以看到：

* 在函数外部，`this`一直是 `Window`类型的对象。（在全局环境中调用的）[即使函数内部的`this`不是`Window`类型。]
* 在函数内部：
	* 如果当前函数被`new funcName(args);`的方式调用，`this`为当`funcName`类型的对象；
	* 如果当前函数没有使用`new`操作符调用，只是普通调用（`var result = funcName(args);`），则`this`是`Window`类型的对象。

> 所以，通过**构造函数模式**确实创建了一个新的对象，而且，这个对象有自己的类型，可以被类型识别到了。

创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。

> TIPS: 以这种方式定义的构造函数是定义在`Global`对象（在浏览器中是`window`对象）中的。

###### 1.将构造函数当作普通函数

**构造函数与其他函数的唯一区别，就在于调用它们的方式不同**。任何函数，只要通过`new`操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过`new`操作符来调用，那它跟普通函数也不会有什么两样。

```javascript
// 当作构造函数使用
var person = new Person("Tom",29,"coder");
person.sayName(); // Tom

// 当成普通函数使用
Person("Ann",28, "actress");
window.sayName(); // Ann
```
> 当成普通函数后，就把`name`,`age`这些属性的值添加到当前执行环境变量中去了，所以`window.name === "Ann"`了。
> 
> ps: 普通函数的`this`对象不一定总是`window`，取决于当前执行环境。

比如下面这种操作，将`Person()`函数的`this`对象指定为`obj`，则后续的添加属性的操作，也就是针对`obj`了。

```javascript
var obj = {};

Person.apply(obj,['Rose' , 26 , 'writer']);

console.log(obj.sayName() +" ### "+obj.age);
// 输出： Rose ### 26
```

###### 2.构造函数的问题

## todo::待续....
